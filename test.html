<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Scale Detector Test</title>
    <link rel="stylesheet" href="./styles.css">
</head>
<body>
        <main class="page">
            <h1>Scale Detector Test</h1>
            <p class="muted">Internal accuracy tester with grid-search tuner (hidden by default).</p>

            <div id="dropzone" class="panel">
                Drag and drop MIDI files here<br>
                (you can select many at once)
            </div>
            <div id="namingHint" class="muted hint">
                Filenames must contain key and mode, e.g. <strong>C_Major.mid</strong> or <strong>G#Minor_MyChords.mid</strong>.
            </div>
            <div id="summary"></div>
            <div id="results"></div>

            <div id="tuner" class="panel">
                <button id="tuneBtn">Tune multipliers (grid search in browser)</button>
                <div id="tuneStatus" style="margin-top:8px; font-size:0.95em;"></div>
                <div id="bestFound" style="margin-top:8px; font-family:monospace;"></div>
            </div>
        </main>

    <script src="https://cdn.jsdelivr.net/npm/@tonejs/midi@2.0.28/build/Midi.js"></script>
    <script type="module">
        const SHOW_TUNER = false; // set to true to show tuner UI
        import { findMatchingScalesWeighted, midiToNoteName } from './scaleDetector.js';

        const dropzone = document.getElementById("dropzone");
        const results = document.getElementById("results");
        const summary = document.getElementById("summary");
        const tuneBtn = document.getElementById("tuneBtn");
        const tuneStatus = document.getElementById("tuneStatus");
        const bestFound = document.getElementById("bestFound");

        if (!SHOW_TUNER) {
            document.getElementById("tuner").style.display = "none";
        }

        // Default multipliers (from tuned 640-file run)
        const DEFAULT_PARAMS = {
            tonicMult: 4.0,
            dominantMult: 1.5,
            subdominantMult: 0.5,
            thirdMult: 1.2,
            wrongThirdPenalty: 0.5,
            outsidePenalty: 3.0
        };

        // Search ranges for tuning (can be tightened/expanded)
        const RANGES = {
            tonic: [3.0, 3.5, 4.0, 4.5, 5.0],
            dominant: [1.2, 1.5, 1.8, 2.0, 2.2],
            subdominant: [0.3, 0.5, 0.8, 1.0, 1.2],
            third: [1.0, 1.2, 1.4, 1.6, 2.0],
            wrongThird: [0.3, 0.5, 0.8, 1.0, 1.5],
            outside: [2.0, 2.5, 3.0, 3.5]
        };

        // In-memory dataset after loading files
        let dataset = [];
        let skippedFiles = [];

        // Parse filename to get expected key and mode (e.g., C_Major.mid, G#Minor.mid, f minor.mid)
        function parseFilename(filename) {
            const name = filename.replace(/\.(mid|midi)$/i, '');
            const match = name.match(/([A-G][#b]?)[\s_\-]*?(Major|Minor)/i);
            if (!match) return null;

            const keyRaw = match[1];
            const modeRaw = match[2];
            const key = keyRaw[0].toUpperCase() + (keyRaw[1] ? keyRaw[1] : '');
            const mode = modeRaw[0].toUpperCase() + modeRaw.slice(1).toLowerCase();
            return { key, mode };
        }

        // Convert note name to MIDI number (C=0, C#=1, etc.)
        function noteNameToMidi(name) {
            const map = {
                "C": 0, "C#": 1, "Db": 1,
                "D": 2, "D#": 3, "Eb": 3,
                "E": 4, "F": 5,
                "F#": 6, "Gb": 6,
                "G": 7, "G#": 8, "Ab": 8,
                "A": 9, "A#": 10, "Bb": 10,
                "B": 11
            };
            const normalized = name[0].toUpperCase() + name.slice(1);
            return map[normalized];
        }

        dropzone.addEventListener("dragover", (e) => {
            e.preventDefault();
            dropzone.classList.add("drag-over");
        });

        dropzone.addEventListener("dragleave", () => {
            dropzone.classList.remove("drag-over");
        });

        dropzone.addEventListener("drop", async (e) => {
            e.preventDefault();
            dropzone.classList.remove("drag-over");
            
            // Reset
            dataset = [];
            skippedFiles = [];
            results.textContent = "Parsing files...\n\n";
            summary.textContent = '';
            bestFound.textContent = '';
            tuneStatus.textContent = '';

            const files = [...e.dataTransfer.files].filter(f => 
                f.name.endsWith('.mid') || f.name.endsWith('.midi')
            );

            for (const file of files) {
                await loadFileToDataset(file);
            }

            const base = evaluateAccuracy(DEFAULT_PARAMS, true);
            renderResults(base);
        });

        // Load a file, parse expected key/mode, extract note weights once
        function loadFileToDataset(file) {
            return new Promise((resolve) => {
                const expected = parseFilename(file.name);

                if (!expected || (expected.mode !== "Major" && expected.mode !== "Minor")) {
                    skippedFiles.push(`${file.name}: missing key/mode (use e.g. C_Major.mid or G#Minor.mid)`);
                    resolve();
                    return;
                }

                const reader = new FileReader();
                reader.onload = () => {
                    const midi = new Midi(reader.result);
                    const noteWeights = new Map();

                    midi.tracks.forEach(track => {
                        track.notes.forEach(note => {
                            const pc = note.midi % 12;
                            noteWeights.set(pc, (noteWeights.get(pc) || 0) + note.duration);
                        });
                    });

                    const usedNotes = [...noteWeights.keys()].sort((a, b) => a - b);
                    const expectedRoot = noteNameToMidi(expected.key);

                    dataset.push({
                        filename: file.name,
                        usedNotes,
                        noteWeights,
                        expectedRoot,
                        expectedMode: expected.mode
                    });

                    resolve();
                };
                reader.readAsArrayBuffer(file);
            });
        }

        function evaluateAccuracy(params, includeDetails = false) {
            let correct = 0;
            const lines = [];

            for (const file of dataset) {
                const matches = findMatchingScalesWeighted(file.usedNotes, file.noteWeights, params);
                const top = matches[0];
                const isCorrect = top.root === file.expectedRoot && top.name === file.expectedMode;
                if (isCorrect) {
                    correct++;
                }

                if (includeDetails) {
                    const topName = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"][top.root];
                    lines.push(
                        `${isCorrect ? '✓ PASS' : '✗ FAIL'}: ${file.filename}\n` +
                        `   Expected: ${midiToNoteName(file.expectedRoot)} ${file.expectedMode}\n` +
                        `   Got: ${topName} ${top.name}\n`
                    );
                }
            }

            return {
                correct,
                total: dataset.length,
                details: lines
            };
        }

        function renderResults(result) {
            if (result.total === 0) {
                summary.textContent = 'No files loaded.';
                return;
            }
            const percentage = ((result.correct / result.total) * 100).toFixed(1);
            summary.innerHTML = `
                <span class="${result.correct === result.total ? 'pass' : 'fail'}">
                    Result: ${result.correct} / ${result.total} correct (${percentage}%)
                </span>
            `;
            const skippedText = skippedFiles.length
                ? `\n\nSkipped files (missing key/mode in filename):\n${skippedFiles.join('\n')}`
                : '';
            results.textContent = result.details.join('\n') + skippedText;
        }

        // Button: run grid search tuning in-browser
        tuneBtn.addEventListener('click', async () => {
            if (!SHOW_TUNER) return;
            if (!dataset.length) {
                tuneStatus.textContent = 'Load files first (drag & drop).';
                return;
            }

            tuneBtn.disabled = true;
            tuneStatus.textContent = 'Tuning in progress...';
            bestFound.textContent = '';

            const combos = RANGES.tonic.length * RANGES.dominant.length * RANGES.subdominant.length *
                RANGES.third.length * RANGES.wrongThird.length * RANGES.outside.length;

            let tested = 0;
            let best = { score: -1, params: null };
            const topList = [];

            for (const tonicMult of RANGES.tonic) {
                for (const dominantMult of RANGES.dominant) {
                    for (const subdominantMult of RANGES.subdominant) {
                        for (const thirdMult of RANGES.third) {
                            for (const wrongThirdPenalty of RANGES.wrongThird) {
                                for (const outsidePenalty of RANGES.outside) {
                                    const params = {
                                        tonicMult,
                                        dominantMult,
                                        subdominantMult,
                                        thirdMult,
                                        wrongThirdPenalty,
                                        outsidePenalty
                                    };

                                    const { correct, total } = evaluateAccuracy(params, false);
                                    tested++;

                                    // Track best single
                                    if (correct > best.score) {
                                        best = { score: correct, params };
                                    }

                                    // Maintain top 40 list (descending by score)
                                    topList.push({ score: correct, params });
                                    topList.sort((a, b) => b.score - a.score);
                                    if (topList.length > 40) topList.length = 40;

                                    // Show snapshot of top list occasionally
                                    if (tested % 500 === 0) {
                                        const lines = topList.map((item, idx) => {
                                            const pct = ((item.score / dataset.length) * 100).toFixed(1);
                                            return `${String(idx + 1).padStart(2, '0')}: ${item.score}/${dataset.length} (${pct}%) ` + JSON.stringify(item.params);
                                        });
                                        bestFound.textContent = lines.join('\n');
                                    }

                                    if (tested % 500 === 0) {
                                        tuneStatus.textContent = `Progress: ${tested}/${combos} (${((tested/combos)*100).toFixed(1)}%)`;
                                        await new Promise(r => setTimeout(r, 0));
                                    }
                                }
                            }
                        }
                    }
                }
            }

            const pct = ((best.score / dataset.length) * 100).toFixed(1);
            tuneStatus.textContent = `Done. Best: ${best.score}/${dataset.length} (${pct}%)`;

            const lines = topList.map((item, idx) => {
                const lpct = ((item.score / dataset.length) * 100).toFixed(1);
                return `${String(idx + 1).padStart(2, '0')}: ${item.score}/${dataset.length} (${lpct}%) ` + JSON.stringify(item.params);
            });
            bestFound.textContent = lines.join('\n');

            tuneBtn.disabled = false;
        });
    </script>
</body>
</html>